class A {
	Int j=1;
	Boolean m(Int i) {
		(new B).m(i-j)
	}
	Int m2(Int i) {
		i+j
	}
}
class B {
	static String s() {
		"Wesh!!"
	}
	Boolean m(Int i) {
		i>0
	}
}
class C {
	Int i;
	static String s() {
		"Coucou"
	}
	C init() {
		i=4; this
	}
	Int m() {
		i+1 // Operation on null (if not init), should raise an error from evaluator
	}
	Int show_i() {
		i
	}
}

class D extends C {
	Int m() {
		i+10
	}	
}

class E extends C {
	Int modif(Int m) {
		i = m
	}
}

new A
new B
2+3
true
2<3
new A != new A
false != true
1 == (1+1-1)
2*4+3;3
(new A).m(1)
(new A).m2(1)
((new C).init()).m()
A a = new A in
	B b = new B in
		(a.m2(1)>0) && b.m(2)
Int i = 5 in
	i+3
((new D).init()).m()
!true;
-45
B b = new B in
	if (b.m(-4)) {
		3
	} else {
		4
	}
B.s()
C d = new E in
	d instanceof D // false
C d = new D in
	d instanceof D // true
2 instanceof Boolean // false, of course

C c = new E in 
	E e = (E)c in ( // objects are passed by reference
		e.modif(100);
		c.show_i()
	)

C c = if (true) {
	new D 
} else {
	new E
} in (
	c.init();
	c.m()
)

// C c = new D in
// 	E e = (E)c in // raises an error
// 		e

// Why the hell are the expressions considered in reverse order ??