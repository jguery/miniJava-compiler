class A {
	Int j=1;
	Boolean m(Int i) {
		(new B).m(i-j)
	}
	Int m2(Int i) {
		i+j
	}
}
class B {
	Boolean m(Int i) {
		i>0
	}
}
class C {
	Int i;
	C init() {
		i=4; this
	}
	Int m() {
		i+1 // Operation on null (if not init), should raise an error from evaluator
	}
}

class D extends C {
	Int m() {
		i+10
	}	
}

new A
new B
2+3
true
2<3
new A != new A
false != true
1 == (1+1-1)
2*4+3;3
(new A).m(1)
(new A).m2(1)
((new C).init()).m()
A a = new A in
	B b = new B in
		(a.m2(1)>0) && b.m(2)
Int i = 5 in
	i+3
((new D).init()).m()
!true;
-45
B b = new B in
	if (b.m(-4)) {
		3
	} else {
		4
	}

// Why the hell are the expressions considered in reverse order ??